input {
  # HTTP input for blockchain events from your API
  http {
    port => 8080
    codec => json
    response_headers => {
      "Access-Control-Allow-Origin" => "*"
      "Content-Type" => "text/plain"
    }
  }
  
  # File input for blockchain logs
  file {
    path => "/usr/share/logstash/logs/blockchain.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => json
  }
  
  # Beats input for system metrics from blockchain service
  beats {
    port => 5044
  }
}

filter {
  # Parse blockchain transaction data
  if [type] == "blockchain" or [message] =~ /blockchain/ {
    mutate {
      add_tag => ["blockchain"]
    }
    
    # Parse blockchain block data
    if [data] {
      mutate {
        add_field => {
          "block_index" => "%{[data][index]}"
          "block_hash" => "%{[data][hash]}"
          "previous_hash" => "%{[data][previousHash]}"
          "block_timestamp" => "%{[data][timestamp]}"
        }
      }
      
      # Parse game results
      if [data][type] == "game_result" {
        mutate {
          add_field => {
            "game_score" => "%{[data][data][score]}"
            "game_project" => "%{[data][data][project]}"
            "result_type" => "game"
          }
          add_tag => ["game_result"]
        }
        
        # Convert score to integer for aggregations
        mutate {
          convert => { "game_score" => "integer" }
        }
      }
      
      # Parse tournament results
      if [data][type] == "tournament_result" {
        mutate {
          add_field => {
            "tournament_id" => "%{[data][data][tournamentId]}"
            "tournament_winner" => "%{[data][data][winner]}"
            "result_type" => "tournament"
          }
          add_tag => ["tournament_result"]
        }
        
        # Extract player data
        if [data][data][players] {
          ruby {
            code => '
              players = event.get("[data][data][players]")
              if players.is_a?(Array)
                event.set("player_count", players.length)
                total_score = players.sum { |p| p["score"] || 0 }
                event.set("total_tournament_score", total_score)
                
                # Find highest score
                max_score = players.map { |p| p["score"] || 0 }.max
                event.set("highest_score", max_score)
              end
            '
          }
        }
      }
    }
    
    # Convert timestamp to proper date
    if [block_timestamp] {
      date {
        match => [ "block_timestamp", "UNIX" ]
        target => "block_date"
      }
    }
  }
  
  # Parse API logs from blockchain service
  if [type] == "api" or [message] =~ /fastify/ {
    mutate {
      add_tag => ["api_log"]
    }
    
    # Parse fastify logs
    json {
      source => "message"
    }
    
    # Extract request information
    if [req] {
      mutate {
        add_field => {
          "request_method" => "%{[req][method]}"
          "request_url" => "%{[req][url]}"
          "request_id" => "%{[req][id]}"
        }
      }
    }
    
    # Extract response information
    if [res] {
      mutate {
        add_field => {
          "response_status" => "%{[res][statusCode]}"
          "response_time" => "%{[responseTime]}"
        }
      }
      
      mutate {
        convert => { 
          "response_status" => "integer" 
          "response_time" => "float"
        }
      }
    }
  }
  
  # Add common fields
  mutate {
    add_field => {
      "service" => "solo-spin-blockchain"
      "environment" => "production"
    }
  }
  
  # Remove unnecessary fields
  mutate {
    remove_field => ["host", "agent", "ecs", "input", "@version"]
  }
}

output {
  # Main blockchain data to dedicated index
  if "blockchain" in [tags] {
    elasticsearch {
      hosts => ["https://es01:9200"]
      user => "elastic"
      password => "iamsuperhero"
      ssl => true
      ssl_certificate_verification => false
      index => "blockchain-data-%{+YYYY.MM.dd}"
      template_name => "blockchain-template"
      template_overwrite => true
      template => {
        "index_patterns" => ["blockchain-data-*"]
        "settings" => {
          "number_of_shards" => 1
          "number_of_replicas" => 0
        }
        "mappings" => {
          "properties" => {
            "block_index" => { "type" => "integer" }
            "block_hash" => { "type" => "keyword" }
            "previous_hash" => { "type" => "keyword" }
            "game_score" => { "type" => "integer" }
            "game_project" => { "type" => "keyword" }
            "tournament_id" => { "type" => "keyword" }
            "result_type" => { "type" => "keyword" }
            "block_date" => { "type" => "date" }
          }
        }
      }
    }
  }
  
  # API logs to separate index
  if "api_log" in [tags] {
    elasticsearch {
      hosts => ["https://es01:9200"]
      user => "elastic"
      password => "iamsuperhero"
      ssl => true
      ssl_certificate_verification => false
      index => "api-logs-%{+YYYY.MM.dd}"
    }
  }
  
  # Debug output (optional)
  if [@metadata][debug] {
    stdout {
      codec => rubydebug
    }
  }
}